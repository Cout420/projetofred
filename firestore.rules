/**
 * Core Philosophy:
 * This ruleset implements a global role-based access control (RBAC) model centered
 * around a single "admin" role. The existence of a user's UID in the /roles_admin
 * collection grants them full administrative privileges across the database.
 * The default posture for anonymous and authenticated non-admin users is read-only
 * access to public content collections.
 *
 * Data Structure:
 * The data is organized into flat, top-level collections. Public-facing content
 * like /testimonials, /services, and /image_gallery is separated from sensitive
 * data like /contact_form_submissions. Administrative roles are managed in a
 * dedicated /roles_admin collection.
 *
 * Key Security Decisions:
 * - Admin Role Check: A single, efficient function `isAdmin()` checks for the
 *   existence of a document at `/roles_admin/{request.auth.uid}` to determine
 *   administrative privileges. This avoids costly `get()` calls in other rules.
 * - Public Data: Collections like /testimonials, /services, and /image_gallery
 *   are publicly readable by anyone, including unauthenticated users, to support
 *   the website's public-facing content. All write operations are restricted
 *   to admins.
 * - "Dropbox" Collection: The /contact_form_submissions collection is designed as a
 *   secure dropbox. Any user (authenticated or not) can create a document, but
 *   no one can read, update, or delete them except for admins. This allows for
 *   a public contact form without exposing submitted data.
 * - Admin Management Lockdown: The /roles_admin collection is read-only from the
 *   client side, even for other admins. This is a critical security measure to
 *   prevent privilege escalation. Admins must be managed out-of-band using the
 *   Firebase Console or a trusted Admin SDK on a server.
 *
 * Denormalization for Authorization:
 * The `/roles_admin/{userId}` collection is the cornerstone of the authorization
 * model. Instead of storing a role field on a user profile document (which doesn't
 * exist in this model), we use a separate collection. A rule can then use a
 * fast `exists()` call to this path to verify a user's role without reading any
 * other documents. This is a highly secure and performant pattern for global roles.
 *
 * Structural Segregation:
 * The ruleset leverages separate collections for data with different security
 * requirements. Publicly readable data (/services) and privately readable data
 * (/contact_form_submissions) are in different top-level collections. This
 * segregation simplifies rules and prevents accidental data leakage, which could
 * occur if both types of data were in a single collection differentiated only
 * by a field flag.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    
    /**
     * Checks if a user is authenticated.
     */
    // function isSignedIn() {
    //   return request.auth != null;
    // }

    /**
     * Checks if the currently authenticated user has an admin role.
     * Admin status is granted by the existence of a document in the roles_admin collection.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * A convenience function for update/delete operations that verifies
     * the user is an admin and the document they are trying to modify exists.
     */
    // function isExistingAdmin() {
    //   return isAdmin() && getAfter() != null;
    // }

    /**
     * @description Publicly readable testimonials. Only admins can create, modify, or delete them.
     * @path /testimonials/{testimonialId}
     * @allow (get) Any user, signed in or not, can read a single testimonial.
     * @deny (create) A non-admin user attempts to add a new testimonial.
     * @principle Public read access for general content, with centralized admin control for all writes.
     */
    match /testimonials/{testimonialId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description A secure "dropbox" for contact form submissions. Anyone can submit, only admins can read.
     * @path /contact_form_submissions/{submissionId}
     * @allow (create) An anonymous website visitor submits the contact form.
     * @deny (get) An anonymous or non-admin user tries to read a submission, even their own.
     * @principle Segregates public write access from private read access to protect user-submitted data.
     */
    match /contact_form_submissions/{submissionId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if true;
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Publicly readable service listings. Only admins can manage the services offered.
     * @path /services/{serviceId}
     * @allow (list) Any user, signed in or not, can list all available services.
     * @deny (update) A non-admin user attempts to change the price of a service.
     * @principle Public read access for general content, with centralized admin control for all writes.
     */
    match /services/{serviceId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Publicly viewable image gallery. Only admins can add, change, or remove images.
     * @path /image_gallery/{galleryItemId}
     * @allow (get) Any user, signed in or not, can view a gallery image.
     * @deny (delete) A non-admin user attempts to remove an image from the gallery.
     * @principle Public read access for general content, with centralized admin control for all writes.
     */
    match /image_gallery/{galleryItemId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Defines user roles. This collection is locked down from client-side writes to prevent privilege escalation.
     * @path /roles_admin/{userId}
     * @allow (get) An admin user reads another user's role document to confirm their status.
     * @deny (create) An admin user attempts to make another user an admin via the client application.
     * @principle Prevents client-side privilege escalation. Roles must be managed via the Firebase Console or a trusted server.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
/**
 * Core Philosophy: This ruleset implements a Database-Based Access Control (DBAC) model.
 * A central `/roles_admin` collection dictates administrative privileges across the entire
 * application. Public-facing content like testimonials, services, and gallery images are

 * globally readable, but all write operations (create, update, delete) are strictly
 * limited to authenticated users designated as admins.
 *
 * Data Structure: The data is organized into flat, top-level collections for each major
 * content type (`/testimonials`, `/services`, `/image_gallery`, `/contact_form_submissions`).
 * A separate `/roles_admin` collection is used exclusively to manage administrative roles.
 *
 * Key Security Decisions:
 * - Admin Role Management: A user is considered an admin if a document with their UID
 *   exists in the `/roles_admin` collection. This provides a clear and manageable way to
 *   control high-privilege access.
 * - Public vs. Private Data: Content intended for public display is globally readable.
 *   Sensitive data, like contact form submissions, is write-only for the public and
 *   readable only by admins.
 * - Secure Role Administration: The `/roles_admin` collection itself is locked down.
 *   It is not writable from any client-side request to prevent users from escalating their
 *   own privileges. Admin roles must be assigned manually via the Firebase Console or a
 *   trusted server environment using the Admin SDK.
 *
 * Denormalization for Authorization: The use of the `/roles_admin/{uid}` collection is a
 * deliberate security pattern. It allows rules to perform a fast and efficient `exists()`
 * check to determine a user's role without needing to read other documents or use custom
 * claims, simplifying the rules and enhancing performance.
 *
 * Structural Segregation: The ruleset leverages separate collections for data with different
 * access patterns. For example, `/testimonials` is public-read while `/contact_form_submissions`
 * is private-read. This segregation is more secure and performant than using a single
 * collection with a status flag, especially for list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    // =================================

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user has an admin role.
     * Admin status is granted if a document with the user's UID exists in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * Verifies that a document exists before an update or delete operation.
     */
    function isExistingDoc() {
      return resource != null;
    }

    // Collection Rules
    // =================================

    /**
     * @description Publicly readable testimonials. Only admins can create, update, or delete them.
     * @path /testimonials/{testimonialId}
     * @allow (get) Any user, signed in or not, can read a testimonial.
     * @deny (create) A non-admin user cannot create a new testimonial.
     * @principle Public read access for content, with writes restricted to privileged roles.
     */
    match /testimonials/{testimonialId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Contact form submissions are write-only for the public. Only admins can read or manage them.
     * @path /contact_form_submissions/{submissionId}
     * @allow (create) Any anonymous or authenticated user can submit the contact form.
     * @deny (get) A non-admin user cannot read a submission, even their own.
     * @principle Protects sensitive user-submitted data by allowing public creation but restricting all reads to admins.
     */
    match /contact_form_submissions/{submissionId} {
      allow get, list: if isAdmin();
      allow create: if true;
      allow update: if false; // Submissions should be immutable for users and admins.
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Publicly readable services. Only admins can create, update, or delete them.
     * @path /services/{serviceId}
     * @allow (list) Any user, signed in or not, can list all available services.
     * @deny (update) A non-admin user cannot modify an existing service.
     * @principle Public read access for content, with writes restricted to privileged roles.
     */
    match /services/{serviceId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Publicly readable image gallery. Only admins can add, update, or remove images.
     * @path /image_gallery/{imageId}
     * @allow (get) Any user, signed in or not, can view a gallery image.
     * @deny (delete) A non-admin user cannot delete a gallery image.
     * @principle Public read access for content, with writes restricted to privileged roles.
     */
    match /image_gallery/{imageId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update, delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Manages admin roles. This collection is locked down from client-side writes to prevent privilege escalation.
     * @path /roles_admin/{uid}
     * @allow (get) An admin can check if another user is an admin.
     * @deny (create) No user can grant themselves or others admin access from the client.
     * @principle Secures the role management system by disallowing all client-side write operations.
     */
    match /roles_admin/{uid} {
      allow get, list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}